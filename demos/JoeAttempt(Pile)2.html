<!DOCTYPE html>
<html>
<head>
    <title>cannon.js - pile demo</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        html,
        body {
            width: 800px;
            height: 500px;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script src="../build/cannon.js"></script>
    <script src="../build/cannon.demo.js"></script>
    <script src="../libs/dat.gui.js"></script>
    <script src="../build/three.js"></script>
    <script src="../libs/TrackballControls.js"></script>
    <script src="../libs/Detector.js"></script>
    <script src="../libs/Stats.js"></script>
    <script src="../libs/smoothie.js"></script>
    <script>



        var world;
        var dt = 1 / 60;

        var constraintDown = false;
        var camera, scene, renderer, gplane = false, clickMarker = false;
        var geometry, material, mesh;
        var controls, time = Date.now();

        var jointBody, constrainedBody, mouseConstraint;

        var N = 1;

        var container, camera, scene, renderer;

        // To be synced
        var meshes = [], bodies = [];

        // Initialize Three.js
        if (!Detector.webgl) Detector.addGetWebGLMessage();

        initCannon();
        init();
        animate();

        function init() {


            container = document.createElement('div');
            document.body.appendChild(container);

            // scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 500, 10000);

            // camera
            camera = new THREE.PerspectiveCamera(30, 800/500, 0.5, 10000);
            camera.position.set(40, 8, -8);
            camera.quaternion.setFromAxisAngle(new THREE.Vector3(-.15, 1, .15), Math.PI / 2);



            scene.add(camera);

            // lights
            var light, materials;
            scene.add(new THREE.AmbientLight(0x666666));

            light = new THREE.DirectionalLight(0xffffff, 1.75);
            var d = 20;

            light.position.set(d, d, d);

            light.castShadow = true;
            //light.shadowCameraVisible = true;

            light.shadow.mapSize.width = 1024;
            light.shadow.mapSize.height = 1024;

            light.shadow.camera.left = -d;
            light.shadow.camera.right = d;
            light.shadow.camera.top = d;
            light.shadow.camera.bottom = -d;

            light.shadow.camera.far = 3 * d;
            light.shadow.camera.near = d;
            
            scene.add(light);

            // floor
            geometry = new THREE.PlaneGeometry(100, 100, 1, 1);
            //geometry.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI / 2 ) );
            material = new THREE.MeshLambertMaterial({ color: 0x777777 });
            markerMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            //THREE.ColorUtils.adjustHSV( material.color, 0, 0, 0.9 );
            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
            mesh.receiveShadow = true;
            scene.add(mesh);

            // cubes
            var cubeGeo = new THREE.BoxGeometry(1, 1, 1, 10, 10);
            var cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            for (var i = 0; i < N; i++) {
                cubeMesh = new THREE.Mesh(cubeGeo, cubeMaterial);
                cubeMesh.castShadow = true;
                meshes.push(cubeMesh);
                scene.add(cubeMesh);
            }

            var texture = new THREE.TextureLoader().load('sunflower.jpg');
            var shape = new THREE.CylinderGeometry(.5, 1, 3, 100, 5);
            var CylinderMaterial = new THREE.MeshPhongMaterial({ map: texture });
            CylinderMesh = new THREE.Mesh(shape, CylinderMaterial);
            CylinderMesh.castShadow = true;
            meshes.push(CylinderMesh);
            scene.add(CylinderMesh);

            var texture = new THREE.TextureLoader().load('Skull.jpg');
            var shape = new THREE.SphereGeometry(1, 100, 100);
            var SphererMaterial = new THREE.MeshPhongMaterial({ map: texture });
            SphererMesh = new THREE.Mesh(shape, SphererMaterial);
            SphererMesh.castShadow = true;
            meshes.push(SphererMesh);
            scene.add(SphererMesh);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(scene.fog.color);

            container.appendChild(renderer.domElement);

            renderer.gammaInput = true;
            renderer.gammaOutput = true;
            renderer.shadowMap.enabled = true;

        }


        function animate() {
            requestAnimationFrame(animate);
            //controls.update();
            updatePhysics();
            render();
        }

        function updatePhysics() {
            world.step(dt);
            for (var i = 0; i !== meshes.length; i++) {
                meshes[i].position.copy(bodies[i].position);
                meshes[i].quaternion.copy(bodies[i].quaternion);
            }
        }

        function render() {
            renderer.render(scene, camera);
        }

        function initCannon() {
            // Setup our world
            world = new CANNON.World();
            world.quatNormalizeSkip = 0;
            world.quatNormalizeFast = false;

            world.gravity.set(0, -10, 0);
            world.broadphase = new CANNON.NaiveBroadphase();

            // Create boxes
            var mass = 5;
            boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
            for (var i = 0; i < N; i++) {
                boxBody = new CANNON.Body({ mass: mass });
                boxBody.addShape(boxShape);
                boxBody.position.set(0, 5, 0);
                world.addBody(boxBody);
                bodies.push(boxBody);
            }

            var mass = 1;
            var size = 1;
            // Cylinder shape
            var cylinderShape2 = new CANNON.Cylinder(.5, 1, 3, 10);
            var q = new CANNON.Quaternion();
            q.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
            cylinderShape2.transformAllPoints(new CANNON.Vec3(), q);
            var cylinderBody2 = new CANNON.Body({ mass: mass });
            cylinderBody2.addShape(cylinderShape2);
            cylinderBody2.position.set(-size * 2, size * 2, 4 * size + 1);
            world.addBody(cylinderBody2);
            bodies.push(cylinderBody2);

            // Sphere Shape
            var cylinderShape = new CANNON.Sphere(1, 100, 100);
            var cylinderBody = new CANNON.Body({ mass: mass });
            cylinderBody.addShape(cylinderShape);
            cylinderBody.position.set(-size * 4, size * 3, 7 * size + 1);
            world.addBody(cylinderBody);
            bodies.push(cylinderBody);

            // Create a plane
            var groundShape = new CANNON.Plane();
            var groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);
        }

        function shape2mesh(body) {
                var wireframe = this.settings.renderMode === "wireframe";
                var obj = new THREE.Object3D();

                for (var l = 0; l < body.shapes.length; l++) {
                    var shape = body.shapes[l];

                    var mesh;

                    switch (shape.type) {

                        case CANNON.Shape.types.SPHERE:
                            var sphere_geometry = new THREE.SphereGeometry(shape.radius, 8, 8);
                            mesh = new THREE.Mesh(sphere_geometry, this.currentMaterial);
                            break;

                        case CANNON.Shape.types.PARTICLE:
                            mesh = new THREE.Mesh(this.particleGeo, this.particleMaterial);
                            var s = this.settings;
                            mesh.scale.set(s.particleSize, s.particleSize, s.particleSize);
                            break;

                        case CANNON.Shape.types.PLANE:
                            var geometry = new THREE.PlaneGeometry(10, 10, 4, 4);
                            mesh = new THREE.Object3D();
                            var submesh = new THREE.Object3D();
                            var ground = new THREE.Mesh(geometry, this.currentMaterial);
                            ground.scale.set(100, 100, 100);
                            submesh.add(ground);

                            ground.castShadow = true;
                            ground.receiveShadow = true;

                            mesh.add(submesh);
                            break;

                        case CANNON.Shape.types.BOX:
                            var box_geometry = new THREE.BoxGeometry(shape.halfExtents.x * 2,
                                shape.halfExtents.y * 2,
                                shape.halfExtents.z * 2);
                            mesh = new THREE.Mesh(box_geometry, this.currentMaterial);
                            break;

                        case CANNON.Shape.types.CONVEXPOLYHEDRON:
                            var geo = new THREE.Geometry();

                            // Add vertices
                            for (var i = 0; i < shape.vertices.length; i++) {
                                var v = shape.vertices[i];
                                geo.vertices.push(new THREE.Vector3(v.x, v.y, v.z));
                            }

                            for (var i = 0; i < shape.faces.length; i++) {
                                var face = shape.faces[i];

                                // add triangles
                                var a = face[0];
                                for (var j = 1; j < face.length - 1; j++) {
                                    var b = face[j];
                                    var c = face[j + 1];
                                    geo.faces.push(new THREE.Face3(a, b, c));
                                }
                            }
                            geo.computeBoundingSphere();
                            geo.computeFaceNormals();
                            mesh = new THREE.Mesh(geo, this.currentMaterial);
                            break;

                        case CANNON.Shape.types.HEIGHTFIELD:
                            var geometry = new THREE.Geometry();

                            var v0 = new CANNON.Vec3();
                            var v1 = new CANNON.Vec3();
                            var v2 = new CANNON.Vec3();
                            for (var xi = 0; xi < shape.data.length - 1; xi++) {
                                for (var yi = 0; yi < shape.data[xi].length - 1; yi++) {
                                    for (var k = 0; k < 2; k++) {
                                        shape.getConvexTrianglePillar(xi, yi, k === 0);
                                        v0.copy(shape.pillarConvex.vertices[0]);
                                        v1.copy(shape.pillarConvex.vertices[1]);
                                        v2.copy(shape.pillarConvex.vertices[2]);
                                        v0.vadd(shape.pillarOffset, v0);
                                        v1.vadd(shape.pillarOffset, v1);
                                        v2.vadd(shape.pillarOffset, v2);
                                        geometry.vertices.push(
                                            new THREE.Vector3(v0.x, v0.y, v0.z),
                                            new THREE.Vector3(v1.x, v1.y, v1.z),
                                            new THREE.Vector3(v2.x, v2.y, v2.z)
                                        );
                                        var i = geometry.vertices.length - 3;
                                        geometry.faces.push(new THREE.Face3(i, i + 1, i + 2));
                                    }
                                }
                            }
                            geometry.computeBoundingSphere();
                            geometry.computeFaceNormals();
                            mesh = new THREE.Mesh(geometry, this.currentMaterial);
                            break;

                        case CANNON.Shape.types.TRIMESH:
                            var geometry = new THREE.Geometry();

                            var v0 = new CANNON.Vec3();
                            var v1 = new CANNON.Vec3();
                            var v2 = new CANNON.Vec3();
                            for (var i = 0; i < shape.indices.length / 3; i++) {
                                shape.getTriangleVertices(i, v0, v1, v2);
                                geometry.vertices.push(
                                    new THREE.Vector3(v0.x, v0.y, v0.z),
                                    new THREE.Vector3(v1.x, v1.y, v1.z),
                                    new THREE.Vector3(v2.x, v2.y, v2.z)
                                );
                                var j = geometry.vertices.length - 3;
                                geometry.faces.push(new THREE.Face3(j, j + 1, j + 2));
                            }
                            geometry.computeBoundingSphere();
                            geometry.computeFaceNormals();
                            mesh = new THREE.Mesh(geometry, this.currentMaterial);
                            break;

                        default:
                            throw "Visual type not recognized: " + shape.type;
                    }

                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    if (mesh.children) {
                        for (var i = 0; i < mesh.children.length; i++) {
                            mesh.children[i].castShadow = true;
                            mesh.children[i].receiveShadow = true;
                            if (mesh.children[i]) {
                                for (var j = 0; j < mesh.children[i].length; j++) {
                                    mesh.children[i].children[j].castShadow = true;
                                    mesh.children[i].children[j].receiveShadow = true;
                                }
                            }
                        }
                    }

                    var o = body.shapeOffsets[l];
                    var q = body.shapeOrientations[l];
                    mesh.position.set(o.x, o.y, o.z);
                    mesh.quaternion.set(q.x, q.y, q.z, q.w);

                    obj.add(mesh);
                }

                return obj;
            }

        function CreateShape(Type, Parameters) {
            switch (Type) {

                case "Sphere":
                    var sphere_geometry = new THREE.SphereGeometry(Parameters.radius, 8, 8);
                    mesh = new THREE.Mesh(sphere_geometry, this.currentMaterial);
                    break;
                case "Cube":

                    break;
                case "Cylinder":

                    break;

            }
        }

    </script>
</body>
</html>
